// Original Code
//                     	// #bubble sort
//                     	// #Execution begins at address 0
// 
// @000                	// .pos 0
//                     	// Init:
// 30f50002000000000000	//   0:  irmovq Stack, %rbp
// 30f40002000000000000	//  10:  irmovq Stack, %rsp
// 700001000000000000  	//  20:  jmp Main
// 
//                     	// # Array of 15 elements // 1 test element not in the array
//                     	// .align 8
// 000000              	// (autogenerated by assembler for alignment)
// @008                	// .pos 0x40
//                     	// Array:
// 0f00000000000000    	//  64:  .quad 15                # 15 values to be sorted
// 0e00000000000000    	//  72:  .quad 14
// 0d00000000000000    	//  80:  .quad 13
// 0c00000000000000    	//  88:  .quad 12
// 0b00000000000000    	//  96:  .quad 11
// 0a00000000000000    	// 104:  .quad 10
// 0900000000000000    	// 112:  .quad 9
// 0800000000000000    	// 120:  .quad 8
// 0700000000000000    	// 128:  .quad 7
// 0600000000000000    	// 136:  .quad 6
// 0500000000000000    	// 144:  .quad 5
// 0400000000000000    	// 152:  .quad 4
// 0300000000000000    	// 160:  .quad 3
// 0200000000000000    	// 168:  .quad 2
// 0100000000000000    	// 176:  .quad 1
// 0101000000000000    	// 184:  .quad 0x00000101        # This value should not change
// 
// @020                	// .pos 0x100
//                     	// Main:
// a05f                	// 256:  pushq   %rbp
// 2045                	// 258:  rrmovq  %rsp, %rbp
// 30f70f00000000000000	// 260:  irmovq  $15, %rdi        # Array size = 6
// 30f64000000000000000	// 270:  irmovq  Array, %rsi
// 800002000000000000  	// 280:  call    Bubble
// 
// 30fa4000000000000000	// 289:  irmovq  Array, %r10     # Use caller-save registers %r10, %r11 first
// 30f00100000000000000	// 299:  irmovq  $1, %rax
// 30fb0800000000000000	// 309:  irmovq  $8, %r11        # size of an element : 8 byte
// 30f30500000000000000	// 319:  irmovq  $5, %rbx        # cnt = last index
// 
//                     	// CheckResult:
// 50ca0000000000000000	// 329:  mrmovq (%r10), %r12     # r12 = a[i]
// 50da0800000000000000	// 339:  mrmovq 8(%r10), %r13    # r13 = a[i+1]
// 61dc                	// 349:  subq   %r13, %r12       # a[i] - a[i+1]  여기서부터 원래 주석이 이상해서 고침
// 767f01000000000000  	// 351:  jg   Fail               # if a[i] > a[i+1], go fail routine
// 
// 60ba                	// 360:  addq   %r11, %r10       # i++
// 6103                	// 362:  subq   %rax, %rbx       # cnt--
// 764901000000000000  	// 364:  jg   CheckResult        # if(cnt > 0) goto CheckResult
// 
//                     	// Passed:
// 30f00000000000000000	// 373:  irmovq $0, %rax         # return 0
// 
//                     	// Fail:
// c00e                	// 383:  mtc0 %rax, $0xe        # return 1
// 00                  	// 385:  halt
// 
// @040                	// .pos 0x200
//                     	// //# void Bubble(long *data, long count)
//                     	// Bubble:
// a05f                	// 512:  pushq   %rbp
// 2045                	// 514:  rrmovq  %rsp, %rbp
// a03f                	// 516:  pushq   %rbx            #Save callee-save registers
// a0cf                	// 518:  pushq   %r12
// 
// 2070                	// 520:  rrmovq  %rdi, %rax      # %rax = count
// 6000                	// 522:  addq    %rax, %rax
// 6000                	// 524:  addq    %rax, %rax
// 6000                	// 526:  addq    %rax, %rax      # %rax = count * 8
// 6060                	// 528:  addq    %rsi, %rax      # %rax = end = data + count
// 
// 2003                	// 530:  rrmovq  %rax, %rbx
// 30f10800000000000000	// 532:  irmovq  $8,   %rcx
// 6113                	// 542:  subq    %rcx, %rbx      # %rbx = last = data + count - 1
// 2031                	// 544:  rrmovq  %rbx, %rcx
// 6161                	// 546:  subq    %rsi, %rcx      # last - data
// 719402000000000000  	// 548:  jle     End             # if(last - data <= 0) goto End
// 
//                     	// Loop1:
// 30f10800000000000000	// 557:  irmovq  $8, %rcx        # %rcx = sizeof(data[i])
// 2062                	// 567:  rrmovq  %rsi, %rdx      # %rdx = i = data
// 
//                     	// Loop2:
// 50a20000000000000000	// 569:  mrmovq  (%rdx), %r10    # r = *i
// 50b20800000000000000	// 579:  mrmovq  8(%rdx), %r11   # s = *(i+1)
// 20bc                	// 589:  rrmovq  %r11, %r12
// 61ac                	// 591:  subq    %r10, %r12      # s-r
// 756e02000000000000  	// 593:  jge     Skip            # Skip if s >= r
// 
//                     	// # swap
// 40a20800000000000000	// 602:  rmmovq  %r10, 8(%rdx)   # *i =s
// 40b20000000000000000	// 612:  rmmovq  %r11, (%rdx)    # *(i+1) = r
// 
//                     	// Skip:
// 6012                	// 622:  addq    %rcx, %rdx      # i++
// 203a                	// 624:  rrmovq  %rbx, %r10      # %r10 = last
// 612a                	// 626:  subq    %rdx, %r10      # last - i
// 763902000000000000  	// 628:  jg      Loop2           # if( i < last ) goto Loop2
// 6113                	// 637:  subq    %rcx, %rbx      # last--
// 30fa0000000000000000	// 639:  irmovq  $0, %r10
// 613a                	// 649:  subq    %rbx, %r10      # if(0 < last) goto Loop1
// 722d02000000000000  	// 651:  jl      Loop1
// 
//                     	// End:
// b0cf                	// 660:  popq    %r12
// b03f                	// 662:  popq    %rbx
// 2054                	// 664:  rrmovq  %rbp, %rsp
// b05f                	// 666:  popq    %rbp
// 90                  	// 668:  ret
// 
// @040                	// .pos 0x200
//                     	// Stack:


// VMH Format Result
@000
30f5000200000000
000030f400020000
0000000070000100
0000000000000000
@008
0f00000000000000
0e00000000000000
0d00000000000000
0c00000000000000
0b00000000000000
0a00000000000000
0900000000000000
0800000000000000
0700000000000000
0600000000000000
0500000000000000
0400000000000000
0300000000000000
0200000000000000
0100000000000000
0101000000000000
@020
a05f204530f70f00
00000000000030f6
4000000000000000
8000020000000000
0030fa4000000000
00000030f0010000
000000000030fb08
0000000000000030
f305000000000000
0050ca0000000000
00000050da080000
000000000061dc76
7f01000000000000
60ba610376490100
000000000030f000
00000000000000c0
0e00000000000000
@040
a05f2045a03fa0cf
2070600060006000
6060200330f10800
0000000000006113
2031616171940200
000000000030f108
0000000000000020
6250a20000000000
00000050b2080000
000000000020bc61
ac756e0200000000
000040a208000000
0000000040b20000
0000000000006012
203a612a76390200
0000000000611330
fa00000000000000
00613a722d020000
00000000b0cfb03f
2054b05f90000000
